\begin{enumerate}
\item[a)] La rutina {\tt mmu_inicializar} en {\tt mmu.c} inicializa en 0 un contador de páginas ocupadas p\'aginas ocupadas, que se ir\'a incrementando en la medida en que se utilicen las p\'aginas, y llama a la funci\'on {\tt mmu_inicializar_dir_kernel}, previamente creada.\\
Contamos también con la función {\tt obtener_pagina_libre} que se encarga de incrementar el contador de páginas ocupadas y retornar el valor de una página libre reservada (estas páginas serán obtenidas del area libre del kernel). Para tratar de evitar problemas de solapamiento, resolvimos incrementar de a 2 el contador de páginas ocupadas, lo que terminaría en la reserva de 2 páginas. TAL VEZ HAY QUE CAMBIAR ESTO.

\item[b)] Se escribe la rutina {\tt mmu_inic_dir_pirata} para inicializar un directorio de páginas y tablas de páginas para una tarea. Esta función solo se encargará de inicializar el directorio de páginas y las tablas para un tarea, en lugar de tener que también copiar el código de la misma, responsabilidades que dejamos para otras funciones. Su funcionamiento resulta muy similar al de inicializar el directorio y las tablas para el kernel. Difiere en el hecho de que se debe pedir una página libre para el directorio y las tablas de páginas, devolviendo la dirección de la página pedida para el directorio.\\

Para el trabajo de copiar el c\'odigo del pirata y mapear las p\'aginas correspondientes, se crean las funciones {\tt copiar\_código} y {\tt mapear\_alrededores} en {\tt mmu.c}. La primera recibe como parámetros un cr3 (de la tarea cuyo código se quiere copiar), dos direcciones virtuales (una destino y otra origen) y una posicion pasada como 2 unsigned ints x e y (que serán pasadas como parámetros al código de la tarea). Esta función transforma las direcciones virtuales y con los otros parámetros antes mencionados llama a {\tt copiar\_fisico} la cual recupera el cr3Actual mediante la función {\tt rcr3}, mapea ambas direcciones fisicas (DST y SRC) a las direcciones {\tt 0x500000} y {\tt 0x501000} (direcciones que no tienen otro uso fuera de este) y tratandolas como punteros a int, se procede a copiar el código desde SRC a DST de a 4 bytes a la vez. Por último, {\tt copiar\_fisico} pasa los parámetros x e y a los últimos 8 bytes del destino y desmapea las 2 páginas mapeadas previamente. Para finalizar, mapeamos a la direccion {\tt 0x400000} la dirección física de destino.
La segunda función, {\tt mapear\_alrededores}, toma un cr3 sobre el cual realizar los mapeos y una dirección virtual Destino. Se pasa luego a transformar la dirección virtual a física y hacer los mapeos, teniendo en cuenta los cálculos correspondientes, para que se mapeen las 9 casillas ocupadas mantiendo una correspondencia entre direccion virtual y física.

\item[c)] Se crean las rutinas encargadas de mapear y desmapear páginas de memoria.

La rutina {\tt mmu\_mapear\_pagina} toma el valor de {\tt cr3} y la direccióon virtual, sobre la cual calcula los índices correspondientes a directorio y tablas de páginas. Luego accede a la entrada del directorio y procede de la siguiente manera: si esta entrada se encuentra como {\it presente}, se accede a la entrada correspondiente de tabla y se realiza el mapeo con la dirección física indicada; en caso contrario, primero se completa dicha entrada pidiendo una página libre y luego se hace el mapeo propiamente dicho.

La rutina {\tt mmu\_unmapear\_pagina} toma el valor actual de {\tt cr3} y la dirección virtual, de la cual calcula los índices correspondientes a directorio y tablas de páginas.  Luego accede a la entrada del directorio y, si estaba como {\it presente}, busca la entrada en la tabla de p\'aginas y la pone como {\it no presente}. En el caso de que ya se encontrar como {\it no presente} no hace ningún cambio.
